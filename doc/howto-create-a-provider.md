---
uid: Uno.Diagnostics.Eventing.CreateProvider
---

## Creating a trace source

The creation of a tracing source requires a nested class named `TraceProvider`, with an `Id` member of type `Guid`, and fields of type int for event type available.

This nested class is required for the creation of the trace manifest generated by the FileEventSink.

```csharp
public class MyDummy
{
    // Gets the event provider for the specified Id
    private readonly static IEventProvider _trace = Tracing.Get(TraceProvider.Id);

    // This class must be nested, and named TraceProvider
    public static class TraceProvider
    {
        public readonly static Guid Id = Guid.Parse("{EA0762E9-1234-1234-XXXX-CC7ECF7BE85E}");

        public const int MyDummy_Created = 1;
        public const int MyDummy_ProcessingStart = 2;
        public const int MyDummy_ProcessingStop = 3;
        public const int MyDummy_ProcessingException = 4;
    }

    public MyDummy()
    {
        // The test is performed before calling the WriteEvent method for performance.
        // Testing a variable is particurlarly cheap, and calling WriteEvent with parameters
        // to be discarded may be a waste of CPU time.

        if (_trace.IsEnabled)
        {
            _trace.WriteEvent(TraceProvider.MyDummy_Created, EventOpcode.Send, new[] { GetType().ToString() });
        }
    }

    public void MyProcessing()
    {
        // The test is performed before calling the WriteEvent method for performance.
        // Testing a variable is particurlarly cheap, and calling WriteEvent with parameters
        // to be discarded may be a waste of CPU time.

        try
        {
            using (
                _trace.WriteEventActivity(
                    TraceProvider.MyDummy_ProcessingStart,
                    TraceProvider.MyDummy_ProcessingStop,
                    relatedActivity: scheduledItem.SourceActivity
                )
            )
            {
                // Do something
            }
        }
        catch(Exception e)
        {
            if (_trace.IsEnabled)
            {
                _trace.WriteEvent(MyDummy_ProcessingException, new[] { e.ToString() });
            }
        }
    }
}
```

In some cases, for performance reasons, it way be relevant to write activity-based tracing this way:

```csharp
IDisposable traceActivity = null;
if (_trace.IsEnabled)
{
    traceActivity = _trace.WriteEventActivity(
        TraceProvider.ArrangeStart,
        TraceProvider.ArrangeStop,
        new object[] { GetType().ToString(), Panel.GetDependencyObjectId() });
}
using (traceActivity)
{
    ArrangeOverride(finalSize);
}
```

Which avoids the creation of a temporary set of variables used for the tracing. Another explored way to do this would have been using a lambda for the payload parameter, but it still creates a delegate and closure over some variables, which has a cost.
